	/**
  ******************************************************************************
  * @file           : Common_Functions.c
  * @brief          : Common Functions and Typedefs code file
  ******************************************************************************
  * @attention
  *
  * (c) 2024 Uniovi E-tech Racing.
  * 
  *
  ******************************************************************************  
  ******************************************************************************
																Version Control
	******************************************************************************
	******************************************************************************		
  Version | dd mmm yyyy |       Who        | Description of changes
  ========|=============|==================|====================================
    1.0   | 01 MAR 2023 | Diego Rodríguez  | Creation
	========|=============|==================|====================================
	
  ******************************************************************************
  ******************************************************************************
  */

/*******************************************************************************
********************************************************************************
***************												INCLUDES					 				***************
********************************************************************************
*******************************************************************************/

#include "Common_Functions.h"


/*******************************************************************************
********************************************************************************
***************										Round float to char			    	 ***************
********************************************************************************
*******************************************************************************/
unsigned char Round (float value)
{
	unsigned char ret;
	ret=(unsigned char)value;
	if ((value-(float)ret)>=0.50)
	{
		ret++;
	}
	return ret;
}


/*******************************************************************************
********************************************************************************
***************								Round high float to char			  	 ***************
********************************************************************************
*******************************************************************************/
unsigned char Round_High (float value)
{
	unsigned char ret;
	ret=(unsigned char)value;
	if ((value-(float)ret)>=0.01)
	{
		ret++;
	}
	return ret;
}


/***************************************************************************************************************************************************************
****************************************************************************************************************************************************************
****************************************************************************************************************************************************************
***************														TIMER STRUCTURE				 ***********************************************************************************************
****************************************************************************************************************************************************************
****************************************************************************************************************************************************************
****************************************************************************************************************************************************************/


/*******************************************************************************
********************************************************************************
***************									TIMER 10ms INIT										 ***************
********************************************************************************
*******************************************************************************/
void Timer_10ms_Init(Timer_10ms_TypeDef* Timer, unsigned short int period, TimerRange_TypeDef range, unsigned int timing)
{
	Timer->Period=period;
	Timer->Range=range;
	Timer->Time=timing;
	Timer->Enabled=FALSE;
	Timer->Overflowed_Counter=0;
	Timer->Overflowed=FALSE;
	Timer->Mili_Seconds_Counter=0;
	Timer->Seconds_Counter=0;
}


/*******************************************************************************
********************************************************************************
***************								TIMER 1 CHANGE TIMING			         ***************
********************************************************************************
*******************************************************************************/
void Timer_10ms_Change_Timing(Timer_10ms_TypeDef* Timer,unsigned int timing)
{
	Timer->Time=timing;

}


/*******************************************************************************
********************************************************************************
***************									TIMER 1 START					  				 ***************
********************************************************************************
*******************************************************************************/
void Timer_10ms_Start(Timer_10ms_TypeDef* Timer)
{
	Timer->Enabled=TRUE;
}


/*******************************************************************************
********************************************************************************
***************										TIMER 1 RESET									 ***************
********************************************************************************
*******************************************************************************/
void Timer_10ms_Reset(Timer_10ms_TypeDef* Timer)
{
	Timer->Enabled=FALSE;
	Timer->Overflowed_Counter=0;
	Timer->Overflowed=FALSE;
	Timer->Mili_Seconds_Counter=0;
	Timer->Seconds_Counter=0;
}


/*******************************************************************************
********************************************************************************
***************									TIMER 1 RESTART									 ***************
********************************************************************************
*******************************************************************************/
void Timer_10ms_Restart(Timer_10ms_TypeDef* Timer)
{
	Timer->Enabled=FALSE;
	Timer_10ms_Reset(Timer);
	Timer->Overflowed=FALSE;
	Timer->Enabled=TRUE;

}



/*******************************************************************************
********************************************************************************
***************										TIMER 1 STOP									 ***************
********************************************************************************
*******************************************************************************/
void Timer_10ms_Stop(Timer_10ms_TypeDef* Timer)
{
	Timer->Enabled=FALSE;
}



/*******************************************************************************
********************************************************************************
***************										TIMER 1 TICK									 ***************
********************************************************************************
*******************************************************************************/
void Timer_10ms_Tick (Timer_10ms_TypeDef* Timer)
{
	if(Timer->Enabled==TRUE)
	{
		Timer->Mili_Seconds_Counter=Timer->Mili_Seconds_Counter+10;

		if(((Timer->Mili_Seconds_Counter>=Timer->Period && Timer->Range==MILISECONDS) || (Timer->Range!=MILISECONDS && Timer->Mili_Seconds_Counter>=1000)) && Timer->Time!=0)
		{
			switch(Timer->Range)
			{
				case MILISECONDS:
					Timer->Overflowed_Counter++;
					//Timer->Enabled=FALSE;
					Timer->Mili_Seconds_Counter=0;
				break;
		
				case SECONDS:
					Timer->Mili_Seconds_Counter=0;
					Timer->Seconds_Counter++;
					if(Timer->Seconds_Counter>=Timer->Period)
					{
						Timer->Overflowed_Counter++;
						//Timer->Enabled=FALSE;
						Timer->Seconds_Counter=0;
					}
				break;
			}
		}
		if((Timer->Overflowed_Counter>=Timer->Time && Timer->Enabled==TRUE) || Timer->Time==0)
		{
			Timer->Overflowed=TRUE;
			Timer->Overflowed_Counter=0;
			Timer->Enabled=FALSE;
		}
	}
}

